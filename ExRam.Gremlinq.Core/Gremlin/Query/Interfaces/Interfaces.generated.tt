<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
using System;
using System.Linq.Expressions;

namespace ExRam.Gremlinq.Core
{
<#
    var untyped = "IGremlinQuery";
    var untypedElement = "IElementGremlinQuery";
    var untypedV = "IVertexGremlinQuery";
    var untypedE = "IEdgeGremlinQuery";

    var typed = "IGremlinQuery<TElement>";
    var typedValue = "IValueGremlinQuery<TElement>";
    var typedArray = "IArrayGremlinQuery<TArray, TQuery>";
    var typedElement = "IElementGremlinQuery<TElement>";
    var typedV = "IVertexGremlinQuery<TVertex>";
    var typedE = "IEdgeGremlinQuery<TEdge>";
    var typedEAdj = "IEdgeGremlinQuery<TEdge, TAdjacentVertex>";
    var typedEBoth = "IEdgeGremlinQuery<TEdge, TOutVertex, TInVertex>";
    var typedInE = "IInEdgeGremlinQuery<TEdge, TAdjacentVertex>";
    var typedOutE = "IOutEdgeGremlinQuery<TEdge, TAdjacentVertex>";
    var typedVP = "IVertexPropertyGremlinQuery<TProperty, TValue>";
    var typedVPMeta = "IVertexPropertyGremlinQuery<TProperty, TValue, TMeta>";
    var typedEP = "IEdgePropertyGremlinQuery<TElement, TValue>";

    var untypedBaseInterfaces = new[]
    {
        untyped,
        untypedElement,
        untypedV,
        untypedE
    };

    var typedBaseInterfaces = new[]
    {
        typed,
        typedValue,
        typedArray,

        typedElement,

        typedV,

        typedE,
        typedEAdj,
        typedEBoth,

        typedInE,
        typedOutE,

        typedVP,
        typedVPMeta,

        typedEP
    };

    var qualifiedInterfaces = new[]
    {
        untypedV,
        untypedE,

        typedValue,
        typedArray,

        typedV,

        typedE,
        typedEAdj,
        typedEBoth,

        typedInE,
        typedOutE,

        typedVP,
        typedVPMeta,

        typedEP
    };

    var typedGraphElementInterfaces = new[]
    {
        typedElement,

        typedV,
        typedE,
        typedEAdj,
        typedEBoth,
        typedInE,
        typedOutE,

        typedVP,
        typedVPMeta
    };

    var typedVerticesAndEdges = new[]
    {
        typedV,
        typedE,
        typedEAdj,
        typedEBoth,
        typedInE,
        typedOutE
    };

    var baseInterfaces = untypedBaseInterfaces.Concat(typedBaseInterfaces);
    var orderedInterfaces = qualifiedInterfaces.Select(x => MakeOrdered(x));

    var allTypedInterfaces = typedBaseInterfaces.Concat(orderedInterfaces.Where(x => GetElement(x) != ""));
    var allInterfaces = baseInterfaces.Concat(orderedInterfaces);




    foreach(var iface in baseInterfaces)
    {
#>
<#
    }





    foreach(var iface in untypedBaseInterfaces)
    {
#>
    public partial interface <#= iface #>
    {
        new <#= iface + "<TResult>" #> Cast<TResult>();
    }

<#
    }





    foreach(var iface in baseInterfaces)
    {
#>
    public partial interface <#= iface #>
    {
        <#= iface #> And(params Func<<#= iface #>, IGremlinQuery>[] andTraversals);

        new <#= iface #> As(params StepLabel[] stepLabels);

        new <#= iface #> Barrier();

        TTargetQuery Choose<TTargetQuery>(Func<<#= iface #>, IGremlinQuery> traversalPredicate, Func<<#= iface #>, TTargetQuery> trueChoice, Func<<#= iface #>, TTargetQuery> falseChoice) where TTargetQuery : IGremlinQuery;
        TTargetQuery Choose<TTargetQuery>(Func<<#= iface #>, IGremlinQuery> traversalPredicate, Func<<#= iface #>, TTargetQuery> trueChoice) where TTargetQuery : IGremlinQuery;

        TTargetQuery Coalesce<TTargetQuery>(params Func<<#= iface #>, TTargetQuery>[] traversals) where TTargetQuery : IGremlinQuery;

        new <#= iface #> Dedup();

        new <#= iface #> Emit();

        new <#= iface #> Filter(string lambda);
        TTargetQuery FlatMap<TTargetQuery>(Func<<#= iface #>, TTargetQuery> mapping) where TTargetQuery : IGremlinQuery;

        new <#= iface #> Identity();

        new <#= iface #> Limit(long count);
        TTargetQuery Local<TTargetQuery>(Func<<#= iface #> , TTargetQuery> localTraversal) where TTargetQuery : IGremlinQuery;

        TTargetQuery Map<TTargetQuery>(Func<<#= iface #>, TTargetQuery> mapping) where TTargetQuery : IGremlinQuery;
        
        <#= iface #> Not(Func<<#= iface #>, IGremlinQuery> notTraversal);

        TTargetQuery Optional<TTargetQuery>(Func<<#= iface #>, TTargetQuery> optionalTraversal) where TTargetQuery : IGremlinQuery;
        <#= iface #> Or(params Func<<#= iface #>, IGremlinQuery>[] orTraversals);

        new <#= iface #> Range(long low, long high);

        TTargetQuery Repeat<TTargetQuery>(Func<<#= iface #>, TTargetQuery> repeatTraversal) where TTargetQuery : <#= iface #>;
        TTargetQuery RepeatUntil<TTargetQuery>(Func<<#= iface #>, TTargetQuery> repeatTraversal, Func<<#= iface #>, IGremlinQuery> untilTraversal) where TTargetQuery : <#= iface #>;

        <#= iface #> SideEffect(Func<<#= iface #>, IGremlinQuery> sideEffectTraversal);
        new <#= iface #> Skip(long count);

        new <#= iface #> Tail(long count);
        new <#= iface #> Times(int count);

        TTargetQuery Union<TTargetQuery>(params Func<<#= iface #>, TTargetQuery>[] unionTraversals) where TTargetQuery : IGremlinQuery;
    }

<#
    }






    foreach(var iface in qualifiedInterfaces)
    {
#>
    public partial interface <#= MakeOrdered(iface) #> : <#= iface #>
    {
    }

    public partial interface <#= iface #>
    {
<#
        if (GetElement(iface) != "")
        {
#>
        new <#= MakeOrdered(iface) #> OrderBy(Expression<Func<<#= GetElement(iface) #>, object>> projection);
        new <#= MakeOrdered(iface) #> OrderByDescending(Expression<Func<<#= GetElement(iface) #>, object>> projection);
<#
        }
#>
        new <#= MakeOrdered(iface) #> OrderBy(Func<<#= iface #>, IGremlinQuery> traversal);
        new <#= MakeOrdered(iface) #> OrderBy(string lambda);
        new <#= MakeOrdered(iface) #> OrderByDescending(Func<<#= iface #>, IGremlinQuery> traversal);
    }
    
<#
    }

    foreach(var iface in qualifiedInterfaces.Select(x => MakeOrdered(x)))
    {
#>
    public partial interface <#= iface #>
    {
<#
        if (GetElement(iface) != "")
        {
#>
        new <#= iface #> ThenBy(Expression<Func<<#= GetElement(iface) #>, object>> projection);
        new <#= iface #> ThenByDescending(Expression<Func<<#= GetElement(iface) #>, object>> projection);
<#
        }
#>
        <#= iface #> ThenBy(Func<<#= MakeUnordered(iface) #>, IGremlinQuery> traversal);
        <#= iface #> ThenByDescending(Func<<#= MakeUnordered(iface) #>, IGremlinQuery> traversal);
        new <#= iface #> ThenBy(string lambda);
    }

<#
    }







    foreach(var iface in typedGraphElementInterfaces)
    {
#>
    public partial interface <#= iface #>
    {

    }

<#
    }




    foreach(var iface in new[] { typedV, typedE })
    {
#>
    public partial interface <#= iface #>
    {
        new IValueGremlinQuery<TTarget> Values<TTarget>(params Expression<Func<<#= GetElement(iface) #>, TTarget>>[] projections);
        new IValueGremlinQuery<TTarget> Values<TTarget>(params Expression<Func<<#= GetElement(iface) #>, TTarget[]>>[] projections);
    }

<#
    }



    foreach(var iface in new[] { untypedV, untypedE })
    {
#>
    public partial interface <#= iface #>
    {
        <#= iface #><TTarget> OfType<TTarget>();
    }

<#
    }




    foreach(var iface in typedVerticesAndEdges)
    {
#>
    public partial interface <#= iface #>
    {
        new <#= iface.Replace(GetElement(iface), "TTarget") #> OfType<TTarget>();

        new <#= iface #> Property<TProjectedValue>(Expression<Func<<#= GetElement(iface) #>, TProjectedValue>> projection, TProjectedValue value);
        new <#= iface #> Property<TProjectedValue>(Expression<Func<<#= GetElement(iface) #>, TProjectedValue[]>> projection, TProjectedValue value);

        new <#= iface #> Where(Expression<Func<<#= GetElement(iface) #>, bool>> predicate);
        new <#= iface #> Where<TProjection>(Expression<Func<<#= GetElement(iface) #>, TProjection>> projection, Func<IGremlinQuery<TProjection>, IGremlinQuery> propertyTraversal);
    }

<#
    }






    foreach(var iface in allTypedInterfaces)
    {
#>
    public partial interface <#= iface #>
    {
        TTargetQuery Aggregate<TTargetQuery>(Func<<#= iface #>, StepLabel<<#= GetElement(iface) #>[]>, TTargetQuery> continuation) where TTargetQuery : IGremlinQuery;
        TTargetQuery As<TTargetQuery>(Func<<#= iface #>, StepLabel<<#= iface #>, <#= GetElement(iface) #>>, TTargetQuery> continuation) where TTargetQuery : IGremlinQuery;

        new <#= iface.Replace(GetElement(iface), "TResult") #> Cast<TResult>();

        new IArrayGremlinQuery<<#= GetElement(iface) #>[], <#= MakeUnordered(iface) #>> Fold();

        new <#= MakeUnordered(iface) #> Where(Func<<#= iface #>, IGremlinQuery> filterTraversal);
    }

<#
    }







    foreach(var iface in allInterfaces)
    {
#>
    public partial interface <#= iface #>
    {

    }

<#
    }
#>
}
#pragma warning restore CS0109 // Member does not hide an inherited member; new keyword is not required




<#+
private string MakeUnordered(string str)
{
    return str.Replace("Ordered", "");
}

private string MakeOrdered(string str)
{
    return "IOrdered" + str.Replace("Ordered", "").Substring(1);
}

private static string GetElement(string str)
{
    var start = str.IndexOf('<');
    if (start == -1)
        return "";

    var end = new[] { str.IndexOf(',', start), str.IndexOf('>', start) }
        .Where(x => x != -1)
        .Min();

    if (end == -1)
        return "";

    return str.Substring(start + 1, end - start - 1);
}
#>
